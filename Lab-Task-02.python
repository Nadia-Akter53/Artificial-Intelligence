1. Write a program to perform BFS traversal on a 2D plane by taking the user input of grid size N. After that generate NÃ—N matrix and place the obstacles randomly. Now print the matrix and take user input of starting and goal state. Then print the required moves throughout the traversal along with the tiles coordinate.

import random
from collections import deque

# Create random grid
def create_grid(n):
    grid = [[0 for _ in range(n)] for _ in range(n)]
    for _ in range(random.randint(n, n*2)):
        x = random.randint(0, n-1)
        y = random.randint(0, n-1)
        grid[x][y] = 1     # 1 means obstacle
    return grid

# Print grid
def show_grid(grid):
    for row in grid:
        print(row)

# BFS Traversal
def bfs(grid, start, goal):
    n = len(grid)
    moves = [("Up", -1, 0), ("Down", 1, 0), ("Left", 0, -1), ("Right", 0, 1)]
    visited = [[False]*n for _ in range(n)]
    queue = deque([(start, [])])
    visited[start[0]][start[1]] = True

    while queue:
        (x, y), path = queue.popleft()

        if (x, y) == goal:
            print("\nGoal reached!\n")
            for move, coord in path:
                print(f"Moving {move} -> {coord}")
            return

        for move, dx, dy in moves:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and not visited[nx][ny]:
                visited[nx][ny] = True
                queue.append(((nx, ny), path + [(move, (nx, ny))]))

    print("No path found!")

# Main part
n = int(input("Enter grid size N: "))
grid = create_grid(n)
print("\nGenerated Grid (1 = obstacle, 0 = free):")
show_grid(grid)

start = tuple(map(int, input("Enter start position (row col): ").split()))
goal = tuple(map(int, input("Enter goal position (row col): ").split()))

bfs(grid, start, goal)


2. Write a program where a robot traverses on a 2D plane using the BFS algorithm and goes from start to destination point. Now print the path it will traverse to reach the destination. (Hint: Save parent state information and use that information to write a recursive function for printing the path.)



from collections import deque
import random

# Create grid
def create_grid(n):
    grid = [[0 for _ in range(n)] for _ in range(n)]
    for _ in range(random.randint(n, n*2)):
        x = random.randint(0, n-1)
        y = random.randint(0, n-1)
        grid[x][y] = 1   # obstacle
    return grid

# Print grid
def show_grid(grid):
    for row in grid:
        print(row)

# Print path (recursive)
def print_path(parent, start, goal):
    if goal == start:
        print(start, end=" -> ")
        return
    print_path(parent, start, parent[goal])
    print(goal, end=" -> ")

# BFS search
def bfs(grid, start, goal):
    n = len(grid)
    directions = [(-1,0), (1,0), (0,-1), (0,1)]
    queue = deque([start])
    parent = {}
    visited = set()
    visited.add(start)

    while queue:
        x, y = queue.popleft()
        if (x, y) == goal:
            print("\nPath found:")
            print_path(parent, start, goal)
            print("\nGoal reached!")
            return

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0 and (nx, ny) not in visited:
                queue.append((nx, ny))
                visited.add((nx, ny))
                parent[(nx, ny)] = (x, y)
    print("No path found!")

# Main
n = int(input("Enter grid size N: "))
grid = create_grid(n)
print("\nGenerated Grid (1 = obstacle, 0 = free):")
show_grid(grid)

start = tuple(map(int, input("Enter start position (row col): ").split()))
goal = tuple(map(int, input("Enter goal position (row col): ").split()))

bfs(grid, start, goal)



10. Write a program where a robot traverses on a 2D plane using the BFS algorithm and goes from start to destination point. Now print the path it will traverse to reach the destination. (Hint: Save parent state information and use that information to write a recursive function for printing the path.)
